/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by upjet. DO NOT EDIT.

package v1beta1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AbortObservation struct {
}

type AbortParameters struct {

	// +kubebuilder:validation:Required
	HTTPStatus *float64 `json:"httpStatus" tf:"http_status,omitempty"`

	// +kubebuilder:validation:Required
	Percentage *float64 `json:"percentage" tf:"percentage,omitempty"`
}

type CorsPolicyObservation struct {
}

type CorsPolicyParameters struct {

	// +kubebuilder:validation:Optional
	AllowCredentials *bool `json:"allowCredentials,omitempty" tf:"allow_credentials,omitempty"`

	// +kubebuilder:validation:Optional
	AllowHeaders []*string `json:"allowHeaders,omitempty" tf:"allow_headers,omitempty"`

	// +kubebuilder:validation:Optional
	AllowMethods []*string `json:"allowMethods,omitempty" tf:"allow_methods,omitempty"`

	// +kubebuilder:validation:Optional
	AllowOriginRegexes []*string `json:"allowOriginRegexes,omitempty" tf:"allow_origin_regexes,omitempty"`

	// +kubebuilder:validation:Optional
	AllowOrigins []*string `json:"allowOrigins,omitempty" tf:"allow_origins,omitempty"`

	// +kubebuilder:validation:Required
	Disabled *bool `json:"disabled" tf:"disabled,omitempty"`

	// +kubebuilder:validation:Optional
	ExposeHeaders []*string `json:"exposeHeaders,omitempty" tf:"expose_headers,omitempty"`

	// +kubebuilder:validation:Optional
	MaxAge *float64 `json:"maxAge,omitempty" tf:"max_age,omitempty"`
}

type DefaultURLRedirectObservation struct {
}

type DefaultURLRedirectParameters struct {

	// +kubebuilder:validation:Optional
	HTTPSRedirect *bool `json:"httpsRedirect,omitempty" tf:"https_redirect,omitempty"`

	// +kubebuilder:validation:Optional
	HostRedirect *string `json:"hostRedirect,omitempty" tf:"host_redirect,omitempty"`

	// +kubebuilder:validation:Optional
	PathRedirect *string `json:"pathRedirect,omitempty" tf:"path_redirect,omitempty"`

	// +kubebuilder:validation:Optional
	PrefixRedirect *string `json:"prefixRedirect,omitempty" tf:"prefix_redirect,omitempty"`

	// +kubebuilder:validation:Optional
	RedirectResponseCode *string `json:"redirectResponseCode,omitempty" tf:"redirect_response_code,omitempty"`

	// +kubebuilder:validation:Required
	StripQuery *bool `json:"stripQuery" tf:"strip_query,omitempty"`
}

type DelayFixedDelayObservation struct {
}

type DelayFixedDelayParameters struct {

	// +kubebuilder:validation:Optional
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// +kubebuilder:validation:Required
	Seconds *string `json:"seconds" tf:"seconds,omitempty"`
}

type DelayObservation struct {
}

type DelayParameters struct {

	// +kubebuilder:validation:Required
	FixedDelay []FixedDelayParameters `json:"fixedDelay" tf:"fixed_delay,omitempty"`

	// +kubebuilder:validation:Required
	Percentage *float64 `json:"percentage" tf:"percentage,omitempty"`
}

type FaultInjectionPolicyAbortObservation struct {
}

type FaultInjectionPolicyAbortParameters struct {

	// +kubebuilder:validation:Optional
	HTTPStatus *float64 `json:"httpStatus,omitempty" tf:"http_status,omitempty"`

	// +kubebuilder:validation:Optional
	Percentage *float64 `json:"percentage,omitempty" tf:"percentage,omitempty"`
}

type FaultInjectionPolicyDelayObservation struct {
}

type FaultInjectionPolicyDelayParameters struct {

	// +kubebuilder:validation:Optional
	FixedDelay []DelayFixedDelayParameters `json:"fixedDelay,omitempty" tf:"fixed_delay,omitempty"`

	// +kubebuilder:validation:Optional
	Percentage *float64 `json:"percentage,omitempty" tf:"percentage,omitempty"`
}

type FaultInjectionPolicyObservation struct {
}

type FaultInjectionPolicyParameters struct {

	// +kubebuilder:validation:Optional
	Abort []AbortParameters `json:"abort,omitempty" tf:"abort,omitempty"`

	// +kubebuilder:validation:Optional
	Delay []DelayParameters `json:"delay,omitempty" tf:"delay,omitempty"`
}

type FixedDelayObservation struct {
}

type FixedDelayParameters struct {

	// +kubebuilder:validation:Optional
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// +kubebuilder:validation:Required
	Seconds *string `json:"seconds" tf:"seconds,omitempty"`
}

type HeaderActionObservation struct {
}

type HeaderActionParameters struct {

	// +kubebuilder:validation:Optional
	RequestHeadersToAdd []RequestHeadersToAddParameters `json:"requestHeadersToAdd,omitempty" tf:"request_headers_to_add,omitempty"`

	// +kubebuilder:validation:Optional
	RequestHeadersToRemove []*string `json:"requestHeadersToRemove,omitempty" tf:"request_headers_to_remove,omitempty"`

	// +kubebuilder:validation:Optional
	ResponseHeadersToAdd []ResponseHeadersToAddParameters `json:"responseHeadersToAdd,omitempty" tf:"response_headers_to_add,omitempty"`

	// +kubebuilder:validation:Optional
	ResponseHeadersToRemove []*string `json:"responseHeadersToRemove,omitempty" tf:"response_headers_to_remove,omitempty"`
}

type HeaderActionRequestHeadersToAddObservation struct {
}

type HeaderActionRequestHeadersToAddParameters struct {

	// +kubebuilder:validation:Required
	HeaderName *string `json:"headerName" tf:"header_name,omitempty"`

	// +kubebuilder:validation:Required
	HeaderValue *string `json:"headerValue" tf:"header_value,omitempty"`

	// +kubebuilder:validation:Required
	Replace *bool `json:"replace" tf:"replace,omitempty"`
}

type HeaderActionResponseHeadersToAddObservation struct {
}

type HeaderActionResponseHeadersToAddParameters struct {

	// +kubebuilder:validation:Required
	HeaderName *string `json:"headerName" tf:"header_name,omitempty"`

	// +kubebuilder:validation:Required
	HeaderValue *string `json:"headerValue" tf:"header_value,omitempty"`

	// +kubebuilder:validation:Required
	Replace *bool `json:"replace" tf:"replace,omitempty"`
}

type HeaderMatchesObservation struct {
}

type HeaderMatchesParameters struct {

	// +kubebuilder:validation:Optional
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// +kubebuilder:validation:Required
	HeaderName *string `json:"headerName" tf:"header_name,omitempty"`

	// If set to false, the headerMatch is considered a match if the match criteria
	// above are met. If set to true, the headerMatch is considered a match if the
	// match criteria above are NOT met. Defaults to false.
	// +kubebuilder:validation:Optional
	InvertMatch *bool `json:"invertMatch,omitempty" tf:"invert_match,omitempty"`

	// +kubebuilder:validation:Optional
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// +kubebuilder:validation:Optional
	PresentMatch *bool `json:"presentMatch,omitempty" tf:"present_match,omitempty"`

	// The header value must be an integer and its value must be in the range specified
	// in rangeMatch. If the header does not contain an integer, number or is empty,
	// the match fails. For example for a range [-5, 0]
	// +kubebuilder:validation:Optional
	RangeMatch []RangeMatchParameters `json:"rangeMatch,omitempty" tf:"range_match,omitempty"`

	// +kubebuilder:validation:Optional
	RegexMatch *string `json:"regexMatch,omitempty" tf:"regex_match,omitempty"`

	// The value of the header must end with the contents of suffixMatch. Only one of
	// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
	// must be set.
	// +kubebuilder:validation:Optional
	SuffixMatch *string `json:"suffixMatch,omitempty" tf:"suffix_match,omitempty"`
}

type HostRuleObservation struct {
}

type HostRuleParameters struct {

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The list of host patterns to match. They must be valid
	// hostnames, except * will match any string of . In
	// that case, * must be the first character and must be followed in
	// the pattern by either - or ..
	// +kubebuilder:validation:Required
	Hosts []*string `json:"hosts" tf:"hosts,omitempty"`

	// +kubebuilder:validation:Required
	PathMatcher *string `json:"pathMatcher" tf:"path_matcher,omitempty"`
}

type MatchRulesMetadataFiltersObservation struct {
}

type MatchRulesMetadataFiltersParameters struct {

	// The list of label value pairs that must match labels in the provided metadata
	// based on filterMatchCriteria  This list must not be empty and can have at the
	// most 64 entries.
	// Structure is documented below.
	// +kubebuilder:validation:Required
	FilterLabels []MetadataFiltersFilterLabelsParameters `json:"filterLabels" tf:"filter_labels,omitempty"`

	// Specifies how individual filterLabel matches within the list of filterLabels
	// contribute towards the overall metadataFilter match. Supported values are:
	// +kubebuilder:validation:Required
	FilterMatchCriteria *string `json:"filterMatchCriteria" tf:"filter_match_criteria,omitempty"`
}

type MatchRulesObservation struct {
}

type MatchRulesParameters struct {

	// For satisfying the matchRule condition, the path of the request must exactly
	// match the value specified in fullPathMatch after removing any query parameters
	// and anchor that may be part of the original URL. FullPathMatch must be between 1
	// and 1024 characters. Only one of prefixMatch, fullPathMatch or regexMatch must
	// be specified.
	// +kubebuilder:validation:Optional
	FullPathMatch *string `json:"fullPathMatch,omitempty" tf:"full_path_match,omitempty"`

	// Specifies a list of header match criteria, all of which must match corresponding
	// headers in the request.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	HeaderMatches []HeaderMatchesParameters `json:"headerMatches,omitempty" tf:"header_matches,omitempty"`

	// Specifies that prefixMatch and fullPathMatch matches are case sensitive.
	// Defaults to false.
	// +kubebuilder:validation:Optional
	IgnoreCase *bool `json:"ignoreCase,omitempty" tf:"ignore_case,omitempty"`

	// Opaque filter criteria used by Loadbalancer to restrict routing configuration to
	// a limited set xDS compliant clients. In their xDS requests to Loadbalancer, xDS
	// clients present node metadata. If a match takes place, the relevant routing
	// configuration is made available to those proxies. For each metadataFilter in
	// this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the
	// filterLabels must match the corresponding label provided in the metadata. If its
	// filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match
	// with corresponding labels in the provided metadata. metadataFilters specified
	// here can be overrides those specified in ForwardingRule that refers to this
	// UrlMap. metadataFilters only applies to Loadbalancers that have their
	// loadBalancingScheme set to INTERNAL_SELF_MANAGED.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	MetadataFilters []MatchRulesMetadataFiltersParameters `json:"metadataFilters,omitempty" tf:"metadata_filters,omitempty"`

	// +kubebuilder:validation:Optional
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// Specifies a list of query parameter match criteria, all of which must match
	// corresponding query parameters in the request.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	QueryParameterMatches []QueryParameterMatchesParameters `json:"queryParameterMatches,omitempty" tf:"query_parameter_matches,omitempty"`

	// +kubebuilder:validation:Optional
	RegexMatch *string `json:"regexMatch,omitempty" tf:"regex_match,omitempty"`
}

type MetadataFiltersFilterLabelsObservation struct {
}

type MetadataFiltersFilterLabelsParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// The value of the label must match the specified value. value can have a maximum
	// length of 1024 characters.
	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type PathMatcherDefaultURLRedirectObservation struct {
}

type PathMatcherDefaultURLRedirectParameters struct {

	// +kubebuilder:validation:Optional
	HTTPSRedirect *bool `json:"httpsRedirect,omitempty" tf:"https_redirect,omitempty"`

	// +kubebuilder:validation:Optional
	HostRedirect *string `json:"hostRedirect,omitempty" tf:"host_redirect,omitempty"`

	// +kubebuilder:validation:Optional
	PathRedirect *string `json:"pathRedirect,omitempty" tf:"path_redirect,omitempty"`

	// +kubebuilder:validation:Optional
	PrefixRedirect *string `json:"prefixRedirect,omitempty" tf:"prefix_redirect,omitempty"`

	// +kubebuilder:validation:Optional
	RedirectResponseCode *string `json:"redirectResponseCode,omitempty" tf:"redirect_response_code,omitempty"`

	// +kubebuilder:validation:Required
	StripQuery *bool `json:"stripQuery" tf:"strip_query,omitempty"`
}

type PathMatcherObservation struct {
}

type PathMatcherParameters struct {

	// +crossplane:generate:reference:type=github.com/upbound/official-providers/provider-gcp/apis/compute/v1beta1.RegionBackendService
	// +crossplane:generate:reference:extractor=github.com/upbound/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	DefaultService *string `json:"defaultService,omitempty" tf:"default_service,omitempty"`

	// Reference to a RegionBackendService in compute to populate defaultService.
	// +kubebuilder:validation:Optional
	DefaultServiceRef *v1.Reference `json:"defaultServiceRef,omitempty" tf:"-"`

	// Selector for a RegionBackendService in compute to populate defaultService.
	// +kubebuilder:validation:Optional
	DefaultServiceSelector *v1.Selector `json:"defaultServiceSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	DefaultURLRedirect []PathMatcherDefaultURLRedirectParameters `json:"defaultUrlRedirect,omitempty" tf:"default_url_redirect,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// The list of path rules. Use this list instead of routeRules when routing based
	// on simple path matching is all that's required. The order by which path rules
	// are specified does not matter. Matches are always done on the longest-path-first
	// basis. For example: a pathRule with a path /a/b/c/* will match before /a/b/*
	// irrespective of the order in which those paths appear in this list. Within a
	// given pathMatcher, only one of pathRules or routeRules must be set.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	PathRule []PathRuleParameters `json:"pathRule,omitempty" tf:"path_rule,omitempty"`

	// The list of ordered HTTP route rules. Use this list instead of pathRules when
	// advanced route matching and routing actions are desired. The order of specifying
	// routeRules matters: the first rule that matches will cause its specified routing
	// action to take effect. Within a given pathMatcher, only one of pathRules or
	// routeRules must be set. routeRules are not supported in UrlMaps intended for
	// External load balancers.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	RouteRules []RouteRulesParameters `json:"routeRules,omitempty" tf:"route_rules,omitempty"`
}

type PathRuleObservation struct {
}

type PathRuleParameters struct {

	// The list of path patterns to match. Each must start with / and the only place a
	// * is allowed is at the end following a /. The string fed to the path matcher
	// does not include any text after the first ? or #, and those chars are not
	// allowed here.
	// +kubebuilder:validation:Required
	Paths []*string `json:"paths" tf:"paths,omitempty"`

	// +kubebuilder:validation:Optional
	RouteAction []RouteActionParameters `json:"routeAction,omitempty" tf:"route_action,omitempty"`

	// +crossplane:generate:reference:type=github.com/upbound/official-providers/provider-gcp/apis/compute/v1beta1.RegionBackendService
	// +crossplane:generate:reference:extractor=github.com/upbound/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	Service *string `json:"service,omitempty" tf:"service,omitempty"`

	// Reference to a RegionBackendService in compute to populate service.
	// +kubebuilder:validation:Optional
	ServiceRef *v1.Reference `json:"serviceRef,omitempty" tf:"-"`

	// Selector for a RegionBackendService in compute to populate service.
	// +kubebuilder:validation:Optional
	ServiceSelector *v1.Selector `json:"serviceSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	URLRedirect []URLRedirectParameters `json:"urlRedirect,omitempty" tf:"url_redirect,omitempty"`
}

type PerTryTimeoutObservation struct {
}

type PerTryTimeoutParameters struct {

	// +kubebuilder:validation:Optional
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// +kubebuilder:validation:Required
	Seconds *string `json:"seconds" tf:"seconds,omitempty"`
}

type QueryParameterMatchesObservation struct {
}

type QueryParameterMatchesParameters struct {

	// +kubebuilder:validation:Optional
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	PresentMatch *bool `json:"presentMatch,omitempty" tf:"present_match,omitempty"`

	// +kubebuilder:validation:Optional
	RegexMatch *string `json:"regexMatch,omitempty" tf:"regex_match,omitempty"`
}

type RangeMatchObservation struct {
}

type RangeMatchParameters struct {

	// The end of the range .
	// +kubebuilder:validation:Required
	RangeEnd *float64 `json:"rangeEnd" tf:"range_end,omitempty"`

	// The start of the range .
	// +kubebuilder:validation:Required
	RangeStart *float64 `json:"rangeStart" tf:"range_start,omitempty"`
}

type RegionURLMapObservation struct {

	// Creation timestamp in RFC3339 text format.
	CreationTimestamp *string `json:"creationTimestamp,omitempty" tf:"creation_timestamp,omitempty"`

	// Fingerprint of this resource. This field is used internally during
	// updates of this resource.
	Fingerprint *string `json:"fingerprint,omitempty" tf:"fingerprint,omitempty"`

	// an identifier for the resource with format projects/{{project}}/regions/{{region}}/urlMaps/{{name}}
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The unique identifier for the resource.
	MapID *float64 `json:"mapId,omitempty" tf:"map_id,omitempty"`

	// The URI of the created resource.
	SelfLink *string `json:"selfLink,omitempty" tf:"self_link,omitempty"`
}

type RegionURLMapParameters struct {

	// +crossplane:generate:reference:type=github.com/upbound/official-providers/provider-gcp/apis/compute/v1beta1.RegionBackendService
	// +crossplane:generate:reference:extractor=github.com/upbound/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	DefaultService *string `json:"defaultService,omitempty" tf:"default_service,omitempty"`

	// Reference to a RegionBackendService in compute to populate defaultService.
	// +kubebuilder:validation:Optional
	DefaultServiceRef *v1.Reference `json:"defaultServiceRef,omitempty" tf:"-"`

	// Selector for a RegionBackendService in compute to populate defaultService.
	// +kubebuilder:validation:Optional
	DefaultServiceSelector *v1.Selector `json:"defaultServiceSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	DefaultURLRedirect []DefaultURLRedirectParameters `json:"defaultUrlRedirect,omitempty" tf:"default_url_redirect,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The list of HostRules to use against the URL.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	HostRule []HostRuleParameters `json:"hostRule,omitempty" tf:"host_rule,omitempty"`

	// +kubebuilder:validation:Optional
	PathMatcher []PathMatcherParameters `json:"pathMatcher,omitempty" tf:"path_matcher,omitempty"`

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	// +kubebuilder:validation:Optional
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// The Region in which the url map should reside.
	// If it is not provided, the provider region is used.
	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"region,omitempty"`

	// The list of expected URL mappings. Requests to update this UrlMap will
	// succeed only if all of the test cases pass.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	Test []TestParameters `json:"test,omitempty" tf:"test,omitempty"`
}

type RequestHeadersToAddObservation struct {
}

type RequestHeadersToAddParameters struct {

	// +kubebuilder:validation:Required
	HeaderName *string `json:"headerName" tf:"header_name,omitempty"`

	// +kubebuilder:validation:Required
	HeaderValue *string `json:"headerValue" tf:"header_value,omitempty"`

	// +kubebuilder:validation:Required
	Replace *bool `json:"replace" tf:"replace,omitempty"`
}

type RequestMirrorPolicyObservation struct {
}

type RequestMirrorPolicyParameters struct {

	// +crossplane:generate:reference:type=github.com/upbound/official-providers/provider-gcp/apis/compute/v1beta1.RegionBackendService
	// +crossplane:generate:reference:extractor=github.com/upbound/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	BackendService *string `json:"backendService,omitempty" tf:"backend_service,omitempty"`

	// Reference to a RegionBackendService in compute to populate backendService.
	// +kubebuilder:validation:Optional
	BackendServiceRef *v1.Reference `json:"backendServiceRef,omitempty" tf:"-"`

	// Selector for a RegionBackendService in compute to populate backendService.
	// +kubebuilder:validation:Optional
	BackendServiceSelector *v1.Selector `json:"backendServiceSelector,omitempty" tf:"-"`
}

type ResponseHeadersToAddObservation struct {
}

type ResponseHeadersToAddParameters struct {

	// +kubebuilder:validation:Required
	HeaderName *string `json:"headerName" tf:"header_name,omitempty"`

	// +kubebuilder:validation:Required
	HeaderValue *string `json:"headerValue" tf:"header_value,omitempty"`

	// +kubebuilder:validation:Required
	Replace *bool `json:"replace" tf:"replace,omitempty"`
}

type RetryPolicyObservation struct {
}

type RetryPolicyParameters struct {

	// +kubebuilder:validation:Optional
	NumRetries *float64 `json:"numRetries,omitempty" tf:"num_retries,omitempty"`

	// +kubebuilder:validation:Optional
	PerTryTimeout []PerTryTimeoutParameters `json:"perTryTimeout,omitempty" tf:"per_try_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	RetryConditions []*string `json:"retryConditions,omitempty" tf:"retry_conditions,omitempty"`
}

type RetryPolicyPerTryTimeoutObservation struct {
}

type RetryPolicyPerTryTimeoutParameters struct {

	// +kubebuilder:validation:Optional
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// +kubebuilder:validation:Required
	Seconds *string `json:"seconds" tf:"seconds,omitempty"`
}

type RouteActionCorsPolicyObservation struct {
}

type RouteActionCorsPolicyParameters struct {

	// +kubebuilder:validation:Optional
	AllowCredentials *bool `json:"allowCredentials,omitempty" tf:"allow_credentials,omitempty"`

	// +kubebuilder:validation:Optional
	AllowHeaders []*string `json:"allowHeaders,omitempty" tf:"allow_headers,omitempty"`

	// +kubebuilder:validation:Optional
	AllowMethods []*string `json:"allowMethods,omitempty" tf:"allow_methods,omitempty"`

	// +kubebuilder:validation:Optional
	AllowOriginRegexes []*string `json:"allowOriginRegexes,omitempty" tf:"allow_origin_regexes,omitempty"`

	// +kubebuilder:validation:Optional
	AllowOrigins []*string `json:"allowOrigins,omitempty" tf:"allow_origins,omitempty"`

	// +kubebuilder:validation:Optional
	Disabled *bool `json:"disabled,omitempty" tf:"disabled,omitempty"`

	// +kubebuilder:validation:Optional
	ExposeHeaders []*string `json:"exposeHeaders,omitempty" tf:"expose_headers,omitempty"`

	// +kubebuilder:validation:Optional
	MaxAge *float64 `json:"maxAge,omitempty" tf:"max_age,omitempty"`
}

type RouteActionFaultInjectionPolicyObservation struct {
}

type RouteActionFaultInjectionPolicyParameters struct {

	// +kubebuilder:validation:Optional
	Abort []FaultInjectionPolicyAbortParameters `json:"abort,omitempty" tf:"abort,omitempty"`

	// +kubebuilder:validation:Optional
	Delay []FaultInjectionPolicyDelayParameters `json:"delay,omitempty" tf:"delay,omitempty"`
}

type RouteActionObservation struct {
}

type RouteActionParameters struct {

	// +kubebuilder:validation:Optional
	CorsPolicy []CorsPolicyParameters `json:"corsPolicy,omitempty" tf:"cors_policy,omitempty"`

	// +kubebuilder:validation:Optional
	FaultInjectionPolicy []FaultInjectionPolicyParameters `json:"faultInjectionPolicy,omitempty" tf:"fault_injection_policy,omitempty"`

	// +kubebuilder:validation:Optional
	RequestMirrorPolicy []RequestMirrorPolicyParameters `json:"requestMirrorPolicy,omitempty" tf:"request_mirror_policy,omitempty"`

	// +kubebuilder:validation:Optional
	RetryPolicy []RetryPolicyParameters `json:"retryPolicy,omitempty" tf:"retry_policy,omitempty"`

	// +kubebuilder:validation:Optional
	Timeout []TimeoutParameters `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// +kubebuilder:validation:Optional
	URLRewrite []URLRewriteParameters `json:"urlRewrite,omitempty" tf:"url_rewrite,omitempty"`

	// +kubebuilder:validation:Optional
	WeightedBackendServices []WeightedBackendServicesParameters `json:"weightedBackendServices,omitempty" tf:"weighted_backend_services,omitempty"`
}

type RouteActionRequestMirrorPolicyObservation struct {
}

type RouteActionRequestMirrorPolicyParameters struct {

	// +kubebuilder:validation:Required
	BackendService *string `json:"backendService" tf:"backend_service,omitempty"`
}

type RouteActionRetryPolicyObservation struct {
}

type RouteActionRetryPolicyParameters struct {

	// +kubebuilder:validation:Required
	NumRetries *float64 `json:"numRetries" tf:"num_retries,omitempty"`

	// +kubebuilder:validation:Optional
	PerTryTimeout []RetryPolicyPerTryTimeoutParameters `json:"perTryTimeout,omitempty" tf:"per_try_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	RetryConditions []*string `json:"retryConditions,omitempty" tf:"retry_conditions,omitempty"`
}

type RouteActionTimeoutObservation struct {
}

type RouteActionTimeoutParameters struct {

	// +kubebuilder:validation:Optional
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// +kubebuilder:validation:Required
	Seconds *string `json:"seconds" tf:"seconds,omitempty"`
}

type RouteActionURLRewriteObservation struct {
}

type RouteActionURLRewriteParameters struct {

	// +kubebuilder:validation:Optional
	HostRewrite *string `json:"hostRewrite,omitempty" tf:"host_rewrite,omitempty"`

	// +kubebuilder:validation:Optional
	PathPrefixRewrite *string `json:"pathPrefixRewrite,omitempty" tf:"path_prefix_rewrite,omitempty"`
}

type RouteActionWeightedBackendServicesObservation struct {
}

type RouteActionWeightedBackendServicesParameters struct {

	// +kubebuilder:validation:Required
	BackendService *string `json:"backendService" tf:"backend_service,omitempty"`

	// +kubebuilder:validation:Optional
	HeaderAction []WeightedBackendServicesHeaderActionParameters `json:"headerAction,omitempty" tf:"header_action,omitempty"`

	// +kubebuilder:validation:Required
	Weight *float64 `json:"weight" tf:"weight,omitempty"`
}

type RouteRulesHeaderActionObservation struct {
}

type RouteRulesHeaderActionParameters struct {

	// +kubebuilder:validation:Optional
	RequestHeadersToAdd []HeaderActionRequestHeadersToAddParameters `json:"requestHeadersToAdd,omitempty" tf:"request_headers_to_add,omitempty"`

	// +kubebuilder:validation:Optional
	RequestHeadersToRemove []*string `json:"requestHeadersToRemove,omitempty" tf:"request_headers_to_remove,omitempty"`

	// +kubebuilder:validation:Optional
	ResponseHeadersToAdd []HeaderActionResponseHeadersToAddParameters `json:"responseHeadersToAdd,omitempty" tf:"response_headers_to_add,omitempty"`

	// +kubebuilder:validation:Optional
	ResponseHeadersToRemove []*string `json:"responseHeadersToRemove,omitempty" tf:"response_headers_to_remove,omitempty"`
}

type RouteRulesObservation struct {
}

type RouteRulesParameters struct {

	// +kubebuilder:validation:Optional
	HeaderAction []RouteRulesHeaderActionParameters `json:"headerAction,omitempty" tf:"header_action,omitempty"`

	// The rules for determining a match.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	MatchRules []MatchRulesParameters `json:"matchRules,omitempty" tf:"match_rules,omitempty"`

	// For routeRules within a given pathMatcher, priority determines the order
	// in which load balancer will interpret routeRules. RouteRules are evaluated
	// in order of priority, from the lowest to highest number. The priority of
	// a rule decreases as its number increases . The first rule
	// that matches the request is applied.
	// You cannot configure two or more routeRules with the same priority.
	// Priority for each rule must be set to a number between 0 and
	// 2147483647 inclusive.
	// Priority numbers can have gaps, which enable you to add or remove rules
	// in the future without affecting the rest of the rules. For example,
	// 1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority numbers to which
	// you could add rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the
	// future without any impact on existing rules.
	// +kubebuilder:validation:Required
	Priority *float64 `json:"priority" tf:"priority,omitempty"`

	// +kubebuilder:validation:Optional
	RouteAction []RouteRulesRouteActionParameters `json:"routeAction,omitempty" tf:"route_action,omitempty"`

	// +crossplane:generate:reference:type=github.com/upbound/official-providers/provider-gcp/apis/compute/v1beta1.RegionBackendService
	// +crossplane:generate:reference:extractor=github.com/upbound/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	Service *string `json:"service,omitempty" tf:"service,omitempty"`

	// Reference to a RegionBackendService in compute to populate service.
	// +kubebuilder:validation:Optional
	ServiceRef *v1.Reference `json:"serviceRef,omitempty" tf:"-"`

	// Selector for a RegionBackendService in compute to populate service.
	// +kubebuilder:validation:Optional
	ServiceSelector *v1.Selector `json:"serviceSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	URLRedirect []RouteRulesURLRedirectParameters `json:"urlRedirect,omitempty" tf:"url_redirect,omitempty"`
}

type RouteRulesRouteActionObservation struct {
}

type RouteRulesRouteActionParameters struct {

	// +kubebuilder:validation:Optional
	CorsPolicy []RouteActionCorsPolicyParameters `json:"corsPolicy,omitempty" tf:"cors_policy,omitempty"`

	// +kubebuilder:validation:Optional
	FaultInjectionPolicy []RouteActionFaultInjectionPolicyParameters `json:"faultInjectionPolicy,omitempty" tf:"fault_injection_policy,omitempty"`

	// +kubebuilder:validation:Optional
	RequestMirrorPolicy []RouteActionRequestMirrorPolicyParameters `json:"requestMirrorPolicy,omitempty" tf:"request_mirror_policy,omitempty"`

	// +kubebuilder:validation:Optional
	RetryPolicy []RouteActionRetryPolicyParameters `json:"retryPolicy,omitempty" tf:"retry_policy,omitempty"`

	// +kubebuilder:validation:Optional
	Timeout []RouteActionTimeoutParameters `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// +kubebuilder:validation:Optional
	URLRewrite []RouteActionURLRewriteParameters `json:"urlRewrite,omitempty" tf:"url_rewrite,omitempty"`

	// +kubebuilder:validation:Optional
	WeightedBackendServices []RouteActionWeightedBackendServicesParameters `json:"weightedBackendServices,omitempty" tf:"weighted_backend_services,omitempty"`
}

type RouteRulesURLRedirectObservation struct {
}

type RouteRulesURLRedirectParameters struct {

	// +kubebuilder:validation:Optional
	HTTPSRedirect *bool `json:"httpsRedirect,omitempty" tf:"https_redirect,omitempty"`

	// +kubebuilder:validation:Optional
	HostRedirect *string `json:"hostRedirect,omitempty" tf:"host_redirect,omitempty"`

	// +kubebuilder:validation:Optional
	PathRedirect *string `json:"pathRedirect,omitempty" tf:"path_redirect,omitempty"`

	// +kubebuilder:validation:Optional
	PrefixRedirect *string `json:"prefixRedirect,omitempty" tf:"prefix_redirect,omitempty"`

	// +kubebuilder:validation:Optional
	RedirectResponseCode *string `json:"redirectResponseCode,omitempty" tf:"redirect_response_code,omitempty"`

	// +kubebuilder:validation:Optional
	StripQuery *bool `json:"stripQuery,omitempty" tf:"strip_query,omitempty"`
}

type TestObservation struct {
}

type TestParameters struct {

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Host portion of the URL.
	// +kubebuilder:validation:Required
	Host *string `json:"host" tf:"host,omitempty"`

	// Path portion of the URL.
	// +kubebuilder:validation:Required
	Path *string `json:"path" tf:"path,omitempty"`

	// +crossplane:generate:reference:type=github.com/upbound/official-providers/provider-gcp/apis/compute/v1beta1.RegionBackendService
	// +crossplane:generate:reference:extractor=github.com/upbound/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	Service *string `json:"service,omitempty" tf:"service,omitempty"`

	// Reference to a RegionBackendService in compute to populate service.
	// +kubebuilder:validation:Optional
	ServiceRef *v1.Reference `json:"serviceRef,omitempty" tf:"-"`

	// Selector for a RegionBackendService in compute to populate service.
	// +kubebuilder:validation:Optional
	ServiceSelector *v1.Selector `json:"serviceSelector,omitempty" tf:"-"`
}

type TimeoutObservation struct {
}

type TimeoutParameters struct {

	// +kubebuilder:validation:Optional
	Nanos *float64 `json:"nanos,omitempty" tf:"nanos,omitempty"`

	// +kubebuilder:validation:Required
	Seconds *string `json:"seconds" tf:"seconds,omitempty"`
}

type URLRedirectObservation struct {
}

type URLRedirectParameters struct {

	// +kubebuilder:validation:Optional
	HTTPSRedirect *bool `json:"httpsRedirect,omitempty" tf:"https_redirect,omitempty"`

	// +kubebuilder:validation:Optional
	HostRedirect *string `json:"hostRedirect,omitempty" tf:"host_redirect,omitempty"`

	// +kubebuilder:validation:Optional
	PathRedirect *string `json:"pathRedirect,omitempty" tf:"path_redirect,omitempty"`

	// +kubebuilder:validation:Optional
	PrefixRedirect *string `json:"prefixRedirect,omitempty" tf:"prefix_redirect,omitempty"`

	// +kubebuilder:validation:Optional
	RedirectResponseCode *string `json:"redirectResponseCode,omitempty" tf:"redirect_response_code,omitempty"`

	// +kubebuilder:validation:Required
	StripQuery *bool `json:"stripQuery" tf:"strip_query,omitempty"`
}

type URLRewriteObservation struct {
}

type URLRewriteParameters struct {

	// +kubebuilder:validation:Optional
	HostRewrite *string `json:"hostRewrite,omitempty" tf:"host_rewrite,omitempty"`

	// +kubebuilder:validation:Optional
	PathPrefixRewrite *string `json:"pathPrefixRewrite,omitempty" tf:"path_prefix_rewrite,omitempty"`
}

type WeightedBackendServicesHeaderActionObservation struct {
}

type WeightedBackendServicesHeaderActionParameters struct {

	// +kubebuilder:validation:Optional
	RequestHeadersToAdd []WeightedBackendServicesHeaderActionRequestHeadersToAddParameters `json:"requestHeadersToAdd,omitempty" tf:"request_headers_to_add,omitempty"`

	// +kubebuilder:validation:Optional
	RequestHeadersToRemove []*string `json:"requestHeadersToRemove,omitempty" tf:"request_headers_to_remove,omitempty"`

	// +kubebuilder:validation:Optional
	ResponseHeadersToAdd []WeightedBackendServicesHeaderActionResponseHeadersToAddParameters `json:"responseHeadersToAdd,omitempty" tf:"response_headers_to_add,omitempty"`

	// +kubebuilder:validation:Optional
	ResponseHeadersToRemove []*string `json:"responseHeadersToRemove,omitempty" tf:"response_headers_to_remove,omitempty"`
}

type WeightedBackendServicesHeaderActionRequestHeadersToAddObservation struct {
}

type WeightedBackendServicesHeaderActionRequestHeadersToAddParameters struct {

	// +kubebuilder:validation:Required
	HeaderName *string `json:"headerName" tf:"header_name,omitempty"`

	// +kubebuilder:validation:Required
	HeaderValue *string `json:"headerValue" tf:"header_value,omitempty"`

	// +kubebuilder:validation:Required
	Replace *bool `json:"replace" tf:"replace,omitempty"`
}

type WeightedBackendServicesHeaderActionResponseHeadersToAddObservation struct {
}

type WeightedBackendServicesHeaderActionResponseHeadersToAddParameters struct {

	// +kubebuilder:validation:Required
	HeaderName *string `json:"headerName" tf:"header_name,omitempty"`

	// +kubebuilder:validation:Required
	HeaderValue *string `json:"headerValue" tf:"header_value,omitempty"`

	// +kubebuilder:validation:Required
	Replace *bool `json:"replace" tf:"replace,omitempty"`
}

type WeightedBackendServicesObservation struct {
}

type WeightedBackendServicesParameters struct {

	// +crossplane:generate:reference:type=github.com/upbound/official-providers/provider-gcp/apis/compute/v1beta1.RegionBackendService
	// +crossplane:generate:reference:extractor=github.com/upbound/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	BackendService *string `json:"backendService,omitempty" tf:"backend_service,omitempty"`

	// Reference to a RegionBackendService in compute to populate backendService.
	// +kubebuilder:validation:Optional
	BackendServiceRef *v1.Reference `json:"backendServiceRef,omitempty" tf:"-"`

	// Selector for a RegionBackendService in compute to populate backendService.
	// +kubebuilder:validation:Optional
	BackendServiceSelector *v1.Selector `json:"backendServiceSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	HeaderAction []HeaderActionParameters `json:"headerAction,omitempty" tf:"header_action,omitempty"`

	// +kubebuilder:validation:Required
	Weight *float64 `json:"weight" tf:"weight,omitempty"`
}

// RegionURLMapSpec defines the desired state of RegionURLMap
type RegionURLMapSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     RegionURLMapParameters `json:"forProvider"`
}

// RegionURLMapStatus defines the observed state of RegionURLMap.
type RegionURLMapStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        RegionURLMapObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// RegionURLMap is the Schema for the RegionURLMaps API. UrlMaps are used to route requests to a backend service based on rules that you define for the host and path of an incoming URL.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,gcp}
type RegionURLMap struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              RegionURLMapSpec   `json:"spec"`
	Status            RegionURLMapStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// RegionURLMapList contains a list of RegionURLMaps
type RegionURLMapList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []RegionURLMap `json:"items"`
}

// Repository type metadata.
var (
	RegionURLMap_Kind             = "RegionURLMap"
	RegionURLMap_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: RegionURLMap_Kind}.String()
	RegionURLMap_KindAPIVersion   = RegionURLMap_Kind + "." + CRDGroupVersion.String()
	RegionURLMap_GroupVersionKind = CRDGroupVersion.WithKind(RegionURLMap_Kind)
)

func init() {
	SchemeBuilder.Register(&RegionURLMap{}, &RegionURLMapList{})
}
